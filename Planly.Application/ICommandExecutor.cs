using System.Threading;
using System.Threading.Tasks;
using MediatR;

namespace Planly.Application
{
	/// <summary>
	/// An object that executes commands that does not return a value.
	/// </summary>
	/// <typeparam name="TCommand">The type of commands this object can execute.</typeparam>
	/// <remarks>Should be implemented for every concrete <see cref="ICommand"/></remarks>
	public interface ICommandExecutor<TCommand> : IRequestHandler<TCommand>
		where TCommand : ICommand
	{
		/// <summary>
		/// Executes a <typeparamref name="TCommand"/>.
		/// </summary>
		/// <param name="command">The command to execute.</param>
		/// <param name="cancellationToken">The token used to cancel the execution.</param>
		Task ExecuteAsync(TCommand command, CancellationToken cancellationToken);

		async Task<Unit> IRequestHandler<TCommand, Unit>.Handle(TCommand command, CancellationToken cancellationToken)
		{
			await ExecuteAsync(command, cancellationToken);
			return Unit.Value;
		}
	}

	/// <summary>
	/// An object that executes commands that returns a value.
	/// </summary>
	/// <typeparam name="TCommand">The type of commands this object can execute.</typeparam>
	/// <typeparam name="TResult">The type of result that is generated by the execution of a <typeparamref name="TCommand"/>.</typeparam>
	/// <remarks>Should be implemented for every concrete <see cref="ICommand{TResult}"/></remarks>
	public interface ICommandExecutor<TCommand, TResult> : IRequestHandler<TCommand, TResult>
		where TCommand : ICommand<TResult>
	{
		/// <summary>
		/// Executes a <typeparamref name="TCommand"/>.
		/// </summary>
		/// <param name="command">The command to execute.</param>
		/// <returns>The result that was produced by the execution of the command.</returns>
		Task<TResult> ExecuteAsync(TCommand command, CancellationToken cancellationToken);

		Task<TResult> IRequestHandler<TCommand, TResult>.Handle(TCommand command, CancellationToken cancellationToken)
		{
			return ExecuteAsync(command, cancellationToken);
		}
	}
}